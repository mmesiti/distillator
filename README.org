#+TITLE: Shoplifter

Steals a Sombrero from HiRep.
It is a set of scripts written in Bash and Python.

* Setup and configuration
To parse the C code (after preprocessing), [[https://github.com/eliben/pycparser][pycparser]] is used.
Pipenv is used to manage the environment, see [[file:Pipfile][Pipfile]].

To be sure that the right versions
of HiRep and Sombrero
are used, please check [[file:remotes.sh][remotes.sh]].

For the lazy,
a Docker image can be used:
[[https://hub.docker.com/repository/docker/michelemesiti/shoplifter][michelemesiti/shoplifter:latest]].
See instruction on that page for usage.

* Steps
These steps are done by [[file:shoplifter.sh][shoplifter.sh]].
If there are changes in HiRep,
some of these steps might fail.

1. Clone HiRep;
2. Build the 6 libraries with the perl/c++ code generator
   with Make from HiRep's makefile;
3. Clone as "thin" version of Sombrero
   (where "thin" means without most of LibHR,
   that will be stolen from HiRep);
4. Label the Sombrero README and benchmark output with the commit ID of the
   Sombrero, HiRep, and shoplifter versions used to generate it.
5. "Graft" Sombrero onto HiRep,
   i.e., copy some files from Sombrero into HiRep
   - sombrero/sombrero directory
   - Include/suN.h
   - Include/sombrero.h
   - Include/suN_repr_func.h
   - Include/libhr_defines_interface.h
   - Include/suN_types.h
   This is done to build ASTs and callgraphs starting from Sombrero's ~main()~ function;
6. Clone pycparser (to use [[https://github.com/eliben/pycparser/tree/master/utils/fake_libc_include][fake_libc_include]] as recommended);
7. Analyse callgraph with sombrero and LibHR, find the useful source files;
8. Copy and clean the useful sources to the "thin Sombrero" repository, filtering out the unused functions;
9. Copy the makefiles to the "thin Sombrero" repository (not overwriting the ones that are already there);
10. Copy and clean the useful headers to the "thin Sombrero" repository;
11. Copy to the "thin Sombrero" repository other manually listed files that for some reason were not detected;
12. Clean the macros in the "thin Sombrero" repository (which is not that thin anymore), in place.
13. Package sombrero in a ~tar.gz~ file.

Note: all the steps are defined in [[file:lib.sh][lib.sh]].

* Tests and verification
This is done by [[file:test.sh][test.sh]].
1. compile the 6 versions of Sombrero
2. run all the 6 benchmarks.


* Packaging
1. TODO:package everything and publish it somewhere accessible

* Internals
The parser needs to work on the preprocessed code,
so it has no cognition of preprocessed directives.
** C AST parsing, callgraph generation and code cleaning
A large number of functions defined in HiRep
is not used at all in Sombrero.
The scripts in the [[file:files_and_functions][files_and_functions]] directory
parse the code, build the call graph
and select only the functions that are used in ~main()~.
Parsing the C code is slow unfortunately,
and theoretically needs to run on all 6 versions of the code
since the preprocessor output is different.
It is likely that the callgraph
does not change betweeen different versions,
but this is needed for correctness.

*** Shoplifter and ~pycparser~
Note that in order to facilitate the parsing,
instead of including the whole standard library
we use the "fake" version provided by ~pycparser~.
In order to access that,
the ~pycparser~ git repository
must be cloned.
Also there are some operations
that need to be performed
at the preprocessing stage
before ~pycparser~ is able to parse the code.

*** Source and Header cleaning
Once the call graph is created
and the used/unused functions are determined,
the unused function definitions
can be removed from the source files.
This cannot be done on the preprocessed sources,
as at that stage the macros have already been expanded,
so ~pycparser~ cannot be used for that.






** Macro selection
Out of the 200 macros that are generated by HiRep,
Only about 25% are really used in Sombrero.
The scripts in the [[file:macros/][macros]] directory
do a thorough search of the codebase
(which, for best results,
needs to be cleaned from unused functions)
and remove the macros that have not been used.
These scripts do not perform any parsing of C syntax.

The scripts in the [[file:macros/][macros]] directory
are a small library that can be used
to remove the unused macros from the sombrero codebase,
that is,
from the ~suN.h~-like and ~suN_repr_func.h~-like
files.
New versions of those files are produced
that can replace the ones in the original directory.
Just run

#+BEGIN_SRC bash
$ python ./main.py <rootdir> <tmpdir>
#+END_SRC

Where ~<rootdir>~ is the directory
that contains sombrero
and the files that need to be cleaned,
and ~<tmpdir>~ is a directory that
will be used to store the results
and temporary files.

This command will create 4 directories.
As far as sombrero packaging is concerned,
we only need the files in the
~*_by_grouprep~ directories.

The files in that directory
can be moved back
to the ~Include~ directory
in the Sombrero repository.

A ~replace_macros.sh~ script is provided
that does all of this.
#+BEGIN_SRC bash
$ ./replace_macros.sh <rootdir>
#+END_SRC
In this case,
the temporary directory
that will be passed to ~main.py~
will be the directory
where the ~replace_macros.sh~ is located.

In this case,
a *backup*
of the old version
of the files containing macros
will be placed where the script is located. 

*** Details

The set of the 4 directories
produced running ~main.py~ 
is the cartesian product of two choices:
- macros for the fundamental vs macros for the representation
  (e.g., ~suN.h~ vs ~suN_repr_func.h~)
- files containing macros grouped ~by_name~ or grouped by version
  (group and representation, ~by_grouprep~)

In addition to the 4 directories,
a list of macros in use
(matching the list of files
contained in the ~macros~ directory)
will be written in the ~used_macros.txt~ file
and in the ~used_macros_repr_func.txt~ file.


* NOTICE: Things that may break
The tools that remove
the unused function declarations and definitions
do not use ~pycparser~,
have been created ad hoc and may fail.
In particular, these tools do not deal with preprocessor branching
and leave preprocessor directive untouched.

For example, the C code
#+BEGIN_SRC c
#ifdef CONDITION
int myfunc(int arg) {
#else
int myfunc(double arg) {
#endif
  /* Body of the function */
}
#+END_SRC
will trip the tools because of the repeated ~{~.
This code will instead be parsed without problems:
#+BEGIN_SRC c
#ifdef CONDITION
int myfunc(int arg)
#else
int myfunc(double arg)
#endif
{
  /* Body of the function */
}
#+END_SRC
